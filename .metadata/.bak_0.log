!SESSION 2021-11-25 09:07:48.149 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-25 09:08:31.179
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-25 09:08:31.179
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1e7cfd49,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3a8640f7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-11-28 21:33:01.436 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-28 21:33:06.710
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-28 21:33:06.710
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@22a63740,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@211da640,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-11-28 23:52:50.188 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-28 23:52:55.477
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-28 23:52:55.478
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76220ef1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@65ad2b42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-11-29 08:41:05.302 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-29 08:41:37.340
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-29 08:41:37.340
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76220ef1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@65ad2b42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-11-30 23:23:22.350 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-11-30 23:23:28.328
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-11-30 23:23:28.328
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@65ad2b42,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@294ebe11,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-01 01:07:11.641 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-12-01 01:07:20.011
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2021-12-01 01:07:21.163
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 01:07:21.163
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@29532e91,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7e691624,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-01 01:58:36.685 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-01 01:58:41.389
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 01:58:41.389
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41f40dfa,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2548fc01,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-01 03:05:57.274 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data file:/home/zineb/BD/ -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-01 03:05:59.421
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 03:05:59.421
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ae2fa13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@66e12c3b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-01 08:41:21.939 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-01 08:41:29.020
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 08:41:29.020
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6774f264,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2299f6d7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-01 08:53:07.076 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-01 08:53:11.301
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 08:53:11.301
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ec92631,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@76220ef1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-01 09:56:10.019 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-01 09:56:15.127
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 09:56:15.127
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@294ebe11,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e51eda7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-01 11:32:56.456 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-01 11:33:01.056
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-01 11:33:01.056
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4583b617,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@22a63740,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 04:31:23.454 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 04:31:48.445
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 04:31:48.445
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e51eda7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2862271a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.jdt.core 4 0 2021-12-02 05:14:15.150
!MESSAGE Invalid ZIP archive: src/shop2.jpg [in Projet_BD]

!ENTRY org.eclipse.jdt.core 4 0 2021-12-02 05:14:24.335
!MESSAGE Invalid ZIP archive: src/shop2.jpg [in Projet_BD]
!SESSION 2021-12-02 08:24:20.492 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 08:24:25.477
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 08:24:25.477
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e51eda7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2862271a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 08:24:31.136 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 08:24:34.960
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 08:24:34.960
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@211da640,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ec92631,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 08:28:56.830 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 08:29:00.983
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 08:29:00.983
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78fb72cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@398694a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 08:29:47.190 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 08:29:51.311
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 08:29:51.311
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e51eda7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2862271a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 08:31:13.183 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 08:31:18.168
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 08:31:18.168
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e51eda7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2862271a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 08:32:03.292 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 08:32:08.816
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 08:32:08.816
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e51eda7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2862271a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 08:37:10.043 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 08:37:14.508
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 08:37:14.508
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e51eda7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2862271a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 11:46:45.542 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 11:46:50.402
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 11:46:50.402
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@78fb72cb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@398694a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 14:17:07.915 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 14:17:13.057
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 14:17:13.057
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@45849604,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6cbbfe29,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 14:18:22.140 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 14:18:27.020
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 14:18:27.020
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e51eda7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2862271a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-02 20:51:40.784 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-02 20:51:47.629
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-02 20:51:47.629
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@294ebe11,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e51eda7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-03 11:29:01.895 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-03 11:29:07.328
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-03 11:29:07.328
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@48aa0813,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@45849604,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-03 14:33:27.228 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-03 14:33:53.019
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-03 14:33:53.019
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@25823192,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3df04fa1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-03 21:22:12.491 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-03 21:22:21.004
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-03 21:22:21.004
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5be69f7e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@64544ee4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 0 2021-12-04 00:44:46.099
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4893)
	at org.eclipse.swt.SWT.error(SWT.java:4808)
	at org.eclipse.swt.SWT.error(SWT.java:4779)
	at org.eclipse.swt.widgets.Display.error(Display.java:1515)
	at org.eclipse.swt.widgets.Display.checkDevice(Display.java:966)
	at org.eclipse.swt.widgets.Display.getShells(Display.java:2783)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:76)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.Workbench.lambda$16(Workbench.java:2744)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5884)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5876)
	at org.eclipse.swt.widgets.Display$SessionManagerListener.isReadyToExit(Display.java:209)
	at org.eclipse.swt.internal.SessionManagerDBus.queryReadyToExit(SessionManagerDBus.java:261)
	at org.eclipse.swt.internal.SessionManagerDBus.handleQueryEndSession(SessionManagerDBus.java:272)
	at org.eclipse.swt.internal.SessionManagerDBus.g_signal_handler(SessionManagerDBus.java:310)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SESSION 2021-12-04 00:45:40.070 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-12-04 00:45:44.128
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2021-12-04 00:45:45.441
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-04 00:45:45.442
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41a8f0d8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30133a11,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-04 01:02:14.676 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -data /home/zineb/BD -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-04 01:02:16.982
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-04 01:02:16.982
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2444c3df,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1eb6037d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 0 2021-12-04 04:17:06.485
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4893)
	at org.eclipse.swt.SWT.error(SWT.java:4808)
	at org.eclipse.swt.SWT.error(SWT.java:4779)
	at org.eclipse.swt.widgets.Display.error(Display.java:1515)
	at org.eclipse.swt.widgets.Display.checkDevice(Display.java:966)
	at org.eclipse.swt.widgets.Display.getShells(Display.java:2783)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:76)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1392)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1368)
	at org.eclipse.ui.internal.Workbench.lambda$16(Workbench.java:2744)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5884)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5876)
	at org.eclipse.swt.widgets.Display$SessionManagerListener.isReadyToExit(Display.java:209)
	at org.eclipse.swt.internal.SessionManagerDBus.queryReadyToExit(SessionManagerDBus.java:261)
	at org.eclipse.swt.internal.SessionManagerDBus.handleQueryEndSession(SessionManagerDBus.java:272)
	at org.eclipse.swt.internal.SessionManagerDBus.g_signal_handler(SessionManagerDBus.java:310)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SESSION 2021-12-04 13:32:51.329 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-12-04 13:33:07.861
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2021-12-04 13:33:09.084
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-04 13:33:09.084
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@54a6ef6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c740c5a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.core.resources 4 2 2021-12-04 16:51:16.190
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.core.resources".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:248)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:205)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findType(Scope.java:2023)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3481)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3168)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:200)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:174)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:390)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:282)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:259)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:661)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:362)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:570)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1503)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1628)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:667)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:902)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:145)
	at java.base/java.lang.Thread.run(Thread.java:833)

!ENTRY org.eclipse.core.resources 4 75 2021-12-04 16:51:16.196
!MESSAGE Errors occurred during the build.
!SUBENTRY 1 org.eclipse.jdt.core 4 75 2021-12-04 16:51:16.196
!MESSAGE Errors running builder 'Java Builder' on project 'Projet_BD'.
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.env.IModule.isAutomatic()" because "module" is null
	at org.eclipse.jdt.internal.compiler.lookup.BinaryModuleBinding.create(BinaryModuleBinding.java:99)
	at org.eclipse.jdt.internal.compiler.impl.ITypeRequestor.accept(ITypeRequestor.java:65)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.getModuleFromAnswer(LookupEnvironment.java:437)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForTypeFromModules(LookupEnvironment.java:374)
	at org.eclipse.jdt.internal.compiler.lookup.LookupEnvironment.askForType(LookupEnvironment.java:236)
	at org.eclipse.jdt.internal.compiler.lookup.UnresolvedReferenceBinding.resolve(UnresolvedReferenceBinding.java:114)
	at org.eclipse.jdt.internal.compiler.lookup.BinaryTypeBinding.resolveType(BinaryTypeBinding.java:248)
	at org.eclipse.jdt.internal.compiler.lookup.PackageBinding.getType(PackageBinding.java:205)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.findType(Scope.java:2023)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getTypeOrPackage(Scope.java:3481)
	at org.eclipse.jdt.internal.compiler.lookup.Scope.getType(Scope.java:3168)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveLeafType(ParameterizedSingleTypeReference.java:200)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.internalResolveType(ParameterizedSingleTypeReference.java:174)
	at org.eclipse.jdt.internal.compiler.ast.ParameterizedSingleTypeReference.resolveType(ParameterizedSingleTypeReference.java:390)
	at org.eclipse.jdt.internal.compiler.ast.TypeReference.resolveType(TypeReference.java:621)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:282)
	at org.eclipse.jdt.internal.compiler.ast.LocalDeclaration.resolve(LocalDeclaration.java:259)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolveStatements(AbstractMethodDeclaration.java:661)
	at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.resolveStatements(MethodDeclaration.java:362)
	at org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:570)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1503)
	at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1628)
	at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:667)
	at org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:902)
	at org.eclipse.jdt.internal.compiler.ProcessTaskManager.run(ProcessTaskManager.java:145)
	at java.base/java.lang.Thread.run(Thread.java:833)
!SESSION 2021-12-04 22:25:24.245 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-04 22:25:29.323
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-04 22:25:29.323
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2862271a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2419fe6f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.ui 4 0 2021-12-05 00:30:57.543
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchPage.getActivePart()" because the return value of "org.eclipse.ui.IWorkbenchWindow.getActivePage()" is null
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.setEnabled(HandlerServiceHandler.java:84)
	at org.eclipse.core.commands.Command.setEnabled(Command.java:856)
	at org.eclipse.ui.menus.CommandContributionItem.isEnabled(CommandContributionItem.java:916)
	at org.eclipse.ui.menus.CommandContributionItem.updateMenuItem(CommandContributionItem.java:531)
	at org.eclipse.ui.menus.CommandContributionItem.update(CommandContributionItem.java:484)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:858)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:858)
	at org.eclipse.ui.internal.Workbench.updateActiveWorkbenchWindowMenuManager(Workbench.java:3152)
	at org.eclipse.ui.internal.Workbench.lambda$0(Workbench.java:3134)
	at org.eclipse.jface.bindings.BindingManager.fireBindingManagerChanged(BindingManager.java:901)
	at org.eclipse.jface.bindings.BindingManager.setActiveBindings(BindingManager.java:2181)
	at org.eclipse.jface.bindings.BindingManager.recomputeBindings(BindingManager.java:1742)
	at org.eclipse.jface.bindings.BindingManager.contextManagerChanged(BindingManager.java:691)
	at org.eclipse.core.commands.contexts.ContextManager.fireContextManagerChanged(ContextManager.java:164)
	at org.eclipse.core.commands.contexts.ContextManager.removeActiveContext(ContextManager.java:245)
	at org.eclipse.ui.internal.contexts.ContextAuthority.updateContext(ContextAuthority.java:695)
	at org.eclipse.ui.internal.contexts.ContextAuthority.activateContext(ContextAuthority.java:168)
	at org.eclipse.ui.internal.contexts.ContextAuthority.checkWindowType(ContextAuthority.java:230)
	at org.eclipse.ui.internal.contexts.ContextAuthority.updateEvaluationContext(ContextAuthority.java:723)
	at org.eclipse.ui.internal.services.ExpressionAuthority.sourceChanged(ExpressionAuthority.java:269)
	at org.eclipse.ui.AbstractSourceProvider.fireSourceChanged(AbstractSourceProvider.java:84)
	at org.eclipse.ui.internal.services.WorkbenchSourceProvider.lambda$2(WorkbenchSourceProvider.java:690)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1527)
	at org.eclipse.swt.widgets.Shell.gtk_focus_in_event(Shell.java:1599)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2413)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:66)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5884)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1522)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:5126)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4576)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchPage.getActivePart()" because the return value of "org.eclipse.ui.IWorkbenchWindow.getActivePage()" is null
	at org.eclipse.lsp4e.operations.rename.LSPRenameHandler.setEnabled(LSPRenameHandler.java:106)
	at org.eclipse.ui.internal.handlers.HandlerProxy.setEnabled(HandlerProxy.java:229)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.setEnabled(E4HandlerProxy.java:133)
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 71 more

!ENTRY org.eclipse.e4.ui.workbench.swt 4 2 2021-12-05 00:30:57.544
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench.swt".
!STACK 0
org.eclipse.e4.core.di.InjectionException: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchPage.getActivePart()" because the return value of "org.eclipse.ui.IWorkbenchWindow.getActivePage()" is null
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.setEnabled(HandlerServiceHandler.java:84)
	at org.eclipse.core.commands.Command.setEnabled(Command.java:856)
	at org.eclipse.ui.menus.CommandContributionItem.isEnabled(CommandContributionItem.java:916)
	at org.eclipse.ui.menus.CommandContributionItem.updateMenuItem(CommandContributionItem.java:531)
	at org.eclipse.ui.menus.CommandContributionItem.update(CommandContributionItem.java:484)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:858)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:858)
	at org.eclipse.ui.internal.Workbench.updateActiveWorkbenchWindowMenuManager(Workbench.java:3152)
	at org.eclipse.ui.internal.Workbench.lambda$0(Workbench.java:3134)
	at org.eclipse.jface.bindings.BindingManager.fireBindingManagerChanged(BindingManager.java:901)
	at org.eclipse.jface.bindings.BindingManager.setActiveBindings(BindingManager.java:2181)
	at org.eclipse.jface.bindings.BindingManager.recomputeBindings(BindingManager.java:1742)
	at org.eclipse.jface.bindings.BindingManager.contextManagerChanged(BindingManager.java:691)
	at org.eclipse.core.commands.contexts.ContextManager.fireContextManagerChanged(ContextManager.java:164)
	at org.eclipse.core.commands.contexts.ContextManager.setActiveContextIds(ContextManager.java:295)
	at org.eclipse.e4.ui.services.ContextServiceAddon$1.changed(ContextServiceAddon.java:49)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:379)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.activate(EclipseContext.java:683)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener$2.run(ShellActivationListener.java:130)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener.activate(ShellActivationListener.java:126)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener.handleEvent(ShellActivationListener.java:76)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1527)
	at org.eclipse.swt.widgets.Shell.gtk_focus_in_event(Shell.java:1599)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2413)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:66)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5884)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1522)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:5126)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4576)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchPage.getActivePart()" because the return value of "org.eclipse.ui.IWorkbenchWindow.getActivePage()" is null
	at org.eclipse.lsp4e.operations.rename.LSPRenameHandler.setEnabled(LSPRenameHandler.java:106)
	at org.eclipse.ui.internal.handlers.HandlerProxy.setEnabled(HandlerProxy.java:229)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.setEnabled(E4HandlerProxy.java:133)
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 73 more

!ENTRY org.eclipse.ui 4 0 2021-12-05 00:31:00.707
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.e4.core.di.InjectionException: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchPage.getActivePart()" because the return value of "org.eclipse.ui.IWorkbenchWindow.getActivePage()" is null
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.setEnabled(HandlerServiceHandler.java:84)
	at org.eclipse.core.commands.Command.setEnabled(Command.java:856)
	at org.eclipse.ui.menus.CommandContributionItem.isEnabled(CommandContributionItem.java:916)
	at org.eclipse.ui.menus.CommandContributionItem.updateMenuItem(CommandContributionItem.java:531)
	at org.eclipse.ui.menus.CommandContributionItem.update(CommandContributionItem.java:484)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:858)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:858)
	at org.eclipse.ui.internal.Workbench.updateActiveWorkbenchWindowMenuManager(Workbench.java:3152)
	at org.eclipse.ui.internal.Workbench.lambda$0(Workbench.java:3134)
	at org.eclipse.jface.bindings.BindingManager.fireBindingManagerChanged(BindingManager.java:901)
	at org.eclipse.jface.bindings.BindingManager.setActiveBindings(BindingManager.java:2181)
	at org.eclipse.jface.bindings.BindingManager.recomputeBindings(BindingManager.java:1742)
	at org.eclipse.jface.bindings.BindingManager.contextManagerChanged(BindingManager.java:691)
	at org.eclipse.core.commands.contexts.ContextManager.fireContextManagerChanged(ContextManager.java:164)
	at org.eclipse.core.commands.contexts.ContextManager.setActiveContextIds(ContextManager.java:295)
	at org.eclipse.e4.ui.services.ContextServiceAddon$1.changed(ContextServiceAddon.java:49)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:379)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:208)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener.lambda$0(ShellActivationListener.java:186)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:127)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5884)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1522)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1527)
	at org.eclipse.swt.widgets.Widget.release(Widget.java:1331)
	at org.eclipse.swt.widgets.Control.release(Control.java:4764)
	at org.eclipse.swt.widgets.Widget.dispose(Widget.java:538)
	at org.eclipse.swt.widgets.Shell.dispose(Shell.java:3316)
	at org.eclipse.jface.window.Window.close(Window.java:335)
	at org.eclipse.jface.dialogs.Dialog.close(Dialog.java:988)
	at org.eclipse.jface.preference.PreferenceDialog.close(PreferenceDialog.java:305)
	at org.eclipse.ui.internal.dialogs.FilteredPreferenceDialog.close(FilteredPreferenceDialog.java:651)
	at org.eclipse.ui.internal.dialogs.WorkbenchPreferenceDialog.close(WorkbenchPreferenceDialog.java:125)
	at org.eclipse.jface.preference.PreferenceDialog.cancelPressed(PreferenceDialog.java:272)
	at org.eclipse.jface.preference.PreferenceDialog.handleShellCloseEvent(PreferenceDialog.java:841)
	at org.eclipse.jface.window.Window$1.shellClosed(Window.java:685)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5884)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1522)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Shell.closeWidget(Shell.java:693)
	at org.eclipse.swt.widgets.Shell.gtk_delete_event(Shell.java:1533)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2403)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.ui.internal.OpenPreferencesAction.run(OpenPreferencesAction.java:66)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:5884)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1522)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:5126)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4576)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchPage.getActivePart()" because the return value of "org.eclipse.ui.IWorkbenchWindow.getActivePage()" is null
	at org.eclipse.lsp4e.operations.rename.LSPRenameHandler.setEnabled(LSPRenameHandler.java:106)
	at org.eclipse.ui.internal.handlers.HandlerProxy.setEnabled(HandlerProxy.java:229)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.setEnabled(E4HandlerProxy.java:133)
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 90 more

!ENTRY org.eclipse.e4.ui.workbench.swt 4 2 2021-12-05 00:31:00.720
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench.swt".
!STACK 0
org.eclipse.e4.core.di.InjectionException: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchPage.getActivePart()" because the return value of "org.eclipse.ui.IWorkbenchWindow.getActivePage()" is null
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:68)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.setEnabled(HandlerServiceHandler.java:84)
	at org.eclipse.core.commands.Command.setEnabled(Command.java:856)
	at org.eclipse.ui.menus.CommandContributionItem.isEnabled(CommandContributionItem.java:916)
	at org.eclipse.ui.menus.CommandContributionItem.updateMenuItem(CommandContributionItem.java:531)
	at org.eclipse.ui.menus.CommandContributionItem.update(CommandContributionItem.java:484)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:858)
	at org.eclipse.jface.action.MenuManager.update(MenuManager.java:858)
	at org.eclipse.ui.internal.Workbench.updateActiveWorkbenchWindowMenuManager(Workbench.java:3152)
	at org.eclipse.ui.internal.Workbench.lambda$0(Workbench.java:3134)
	at org.eclipse.jface.bindings.BindingManager.fireBindingManagerChanged(BindingManager.java:901)
	at org.eclipse.jface.bindings.BindingManager.setActiveBindings(BindingManager.java:2181)
	at org.eclipse.jface.bindings.BindingManager.recomputeBindings(BindingManager.java:1742)
	at org.eclipse.jface.bindings.BindingManager.contextManagerChanged(BindingManager.java:691)
	at org.eclipse.core.commands.contexts.ContextManager.fireContextManagerChanged(ContextManager.java:164)
	at org.eclipse.core.commands.contexts.ContextManager.setActiveContextIds(ContextManager.java:295)
	at org.eclipse.e4.ui.services.ContextServiceAddon$1.changed(ContextServiceAddon.java:49)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.set(EclipseContext.java:379)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.activate(EclipseContext.java:683)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.activateBranch(EclipseContext.java:692)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener$1.run(ShellActivationListener.java:99)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener.processWindow(ShellActivationListener.java:95)
	at org.eclipse.e4.ui.internal.workbench.swt.ShellActivationListener.handleEvent(ShellActivationListener.java:65)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1527)
	at org.eclipse.swt.widgets.Shell.gtk_focus_in_event(Shell.java:1599)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2413)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.IWorkbenchPage.getActivePart()" because the return value of "org.eclipse.ui.IWorkbenchWindow.getActivePage()" is null
	at org.eclipse.lsp4e.operations.rename.LSPRenameHandler.setEnabled(LSPRenameHandler.java:106)
	at org.eclipse.ui.internal.handlers.HandlerProxy.setEnabled(HandlerProxy.java:229)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.setEnabled(E4HandlerProxy.java:133)
	at jdk.internal.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	... 63 more
!SESSION 2021-12-05 00:31:04.845 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-05 00:31:11.152
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-05 00:31:11.152
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60a99f3d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@57515944,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SESSION 2021-12-05 11:10:39.328 -----------------------------------------------
eclipse.buildId=4.21.0.I20210906-0500
java.version=17
java.vendor=Eclipse Adoptium
BootLoader constants: OS=linux, ARCH=x86_64, WS=gtk, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os linux -ws gtk -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-12-05 11:10:44.869
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-12-05 11:10:44.869
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@398694a6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@653e7b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:52:56.932
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery(+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
            		
            		+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:52:56.934
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:52:56.935
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:52:57.906
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery(+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
            		
            		+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:52:57.907
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:52:57.907
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:01.029
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery(+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
            		
            		+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:01.029
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:01.029
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:01.815
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery(+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
            		
            		+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:01.817
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:01.817
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:04.446
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery(+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
            		
   
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:53:04.446
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:53:04.447
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:05.437
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery(+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
            		
   
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:05.438
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:05.438
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:08.957
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery(+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:53:08.957
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:53:08.957
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:10.000
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery(+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:10.001
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:10.001
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:18.013
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery(+ "Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:18.014
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:18.014
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:19.970
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:53:19.970
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:53:19.970
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:20.654
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:20.655
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:20.655
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:23.194
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1570)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:923)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:4000)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2415)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:23.195
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1570)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:923)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:4000)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2415)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:23.195
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1570)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:923)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:4000)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2415)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:23.675
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:23.675
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:23.675
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:24.785
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:24.786
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:24.786
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:29.503
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:53:29.504
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:53:29.504
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:53:30.037
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
          
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:53:30.037
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:53:30.038
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:00.172
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON"	);
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:58:00.172
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:58:00.172
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:00.852
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON"	);
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:00.853
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:00.853
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:04.180
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:58:04.181
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:58:04.181
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:04.844
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:04.844
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:04.844
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:07.980
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1570)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:923)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:4000)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2415)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:07.981
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1570)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:923)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:4000)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2415)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:07.981
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1570)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:923)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:4000)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2415)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:08.574
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:08.575
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:08.575
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:10.692
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:58:10.692
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:58:10.692
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:14.203
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");

            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:58:14.203
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:58:14.203
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:15.212
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:58:15.212
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:58:15.212
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:16.111
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:16.111
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:16.111
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:17.570
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:17.570
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:17.570
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:18.737
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt=connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:58:18.737
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:58:18.737
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:19.748
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:58:19.748
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:58:19.748
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:20.657
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:20.657
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:20.657
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:22.263
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt4.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 14:58:22.263
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 14:58:22.264
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:22.697
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt4.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:22.698
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:22.698
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:24.923
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt4.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:24.923
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:24.923
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 14:58:27.390
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt4.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 14:58:27.392
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 14:58:27.392
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 15:01:00.831
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt4.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 15:01:00.831
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 15:01:00.831
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:139)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:118)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 15:01:01.083
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt4.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1570)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:923)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:4000)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2415)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 15:01:01.083
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1570)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:923)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:4000)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2415)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 15:01:01.084
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.getClipboardData(ClipboardOperationAction.java:479)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.doCutCopyWithImportsOperation(ClipboardOperationAction.java:406)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.internalDoOperation(ClipboardOperationAction.java:365)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.jdt.internal.ui.javaeditor.ClipboardOperationAction.run(ClipboardOperationAction.java:286)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.commands.ActionHandler.execute(ActionHandler.java:121)
	at org.eclipse.ui.internal.handlers.E4HandlerProxy.execute(E4HandlerProxy.java:97)
	at jdk.internal.reflect.GeneratedMethodAccessor58.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invokeUsingClass(InjectorImpl.java:317)
	at org.eclipse.e4.core.internal.di.InjectorImpl.invoke(InjectorImpl.java:251)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.invoke(ContextInjectionFactory.java:173)
	at org.eclipse.e4.core.commands.internal.HandlerServiceHandler.execute(HandlerServiceHandler.java:156)
	at org.eclipse.core.commands.Command.executeWithChecks(Command.java:488)
	at org.eclipse.core.commands.ParameterizedCommand.executeWithChecks(ParameterizedCommand.java:487)
	at org.eclipse.e4.core.commands.internal.HandlerServiceImpl.executeHandler(HandlerServiceImpl.java:213)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.executeCommand(KeyBindingDispatcher.java:308)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.press(KeyBindingDispatcher.java:580)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.processKeyEvent(KeyBindingDispatcher.java:647)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher.filterKeySequenceBindings(KeyBindingDispatcher.java:439)
	at org.eclipse.e4.ui.bindings.keys.KeyBindingDispatcher$KeyDownFilter.handleEvent(KeyBindingDispatcher.java:96)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.filterEvent(Display.java:1934)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1521)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1548)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1531)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1570)
	at org.eclipse.swt.widgets.Widget.gtk_key_press_event(Widget.java:923)
	at org.eclipse.swt.widgets.Control.gtk_key_press_event(Control.java:4000)
	at org.eclipse.swt.widgets.Composite.gtk_key_press_event(Composite.java:925)
	at org.eclipse.swt.widgets.Widget.windowProc(Widget.java:2415)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:6840)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:6147)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_do_event(Native Method)
	at org.eclipse.swt.widgets.Display.eventProc(Display.java:1562)
	at org.eclipse.swt.internal.gtk3.GTK3.gtk_main_iteration_do(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:4573)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1150)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1041)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 15:01:01.474
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt4.executeQuery("Drop View MostBidON");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2021-12-05 15:01:01.474
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2021-12-05 15:01:01.475
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 15:01:05.813
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt4.executeQuery("Drop View Mothers");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-12-05 15:01:05.813
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-12-05 15:01:05.814
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:501)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-12-05 15:01:06.499
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package CodeSr;

import static javax.swing.JOptionPane.showMessageDialog;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Categories {
	
	static final String CONN_URL = "jdbc:oracle:thin:@oracle1.ensimag.fr:1521:oracle1";
    static final String USER = "echarifs";
    static final String PASSWD = "echarifs";
	
    public static String[] categorieSRoot() {
    	String[] categories=null;
    	/*** récuperer de la base des données les catégories ROOT ***/
    	try {
    	   	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE)");
            ResultSet result = query.executeQuery();
            // nombre des categories root est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT(NOMMERE) FROM ( SELECT DISTINCT NOMMERE FROM HIERARCHIE WHERE NOMMERE NOT IN (SELECT NOMFILLE FROM HIERARCHIE))");
            ResultSet res = query1.executeQuery();
            res.next();
            int categoriesRootNbr=res.getInt(1);
            categories=new String[categoriesRootNbr];
            for(int i=0;i<categoriesRootNbr;i++){
                result.next();
            	categories[i]=result.getString(1);
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories;
    }

    public static String[] categoriesFilles(String categorie) {
    	String[] categories=null;
    	/*** recuperer de la base de données les catégories filles de la premières géneration d'une catégorie donnée ***/
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();
      
            // nombre des categories filles  est 
            PreparedStatement query1=connexion.prepareStatement("SELECT  COUNT( NOMFILLE) FROM ( SELECT NOMFILLE FROM HIERARCHIE WHERE NOMMERE = ?)");
            query1.setString(1, categorie);
            ResultSet res = query1.executeQuery(); 
            res.next();
            int categoriesFillesNbr=res.getInt(1);
            categories=new String[categoriesFillesNbr];
            if(categoriesFillesNbr!=0) {
                for(int i=0;i<categoriesFillesNbr;i++){
                    result.next();
                	categories[i]=result.getString(1);
                }
            }


            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return categories ;
    }
    public static boolean inCategorie(String categorie) {
    	boolean has=false;
    	try {	
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            PreparedStatement query=connexion.prepareStatement("SELECT  * FROM CATEGORIE WHERE NOM=?");
            query.setString(1, categorie);
            ResultSet result = query.executeQuery();        
            has= result.next();
            
    	}
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return has;
            
    }
    public static String[] hasProducts(String categorie) {
    	/*** for category  that have not subcategories return  String[] of product's ID if category in Categorie ; String[] is empty if category has any products ***/
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection       
            if (Categories.inCategorie(categorie)) {
            	/* categorie qui a  de produits*/ 
                PreparedStatement query1=connexion.prepareStatement("SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ?\n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE = ? AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
                query1.setString(1, categorie);
                query1.setString(2, categorie);
                ResultSet res = query1.executeQuery(); 
                /* nombre de produits dans cette categorie */
                PreparedStatement query2=connexion.prepareStatement("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
                		+ "WHERE NOMCATEGORIE = ? \n"
                		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
                		+ "UNION ALL\n"
                		+ "SELECT b.* FROM\n"
                		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE NOMCATEGORIE =  ?  AND PRODUIT.IDPRODUIT\n"
                		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                query2.setString(1, categorie);
                query2.setString(2, categorie);
                ResultSet reslt = query2.executeQuery(); 
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            }
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	
    	return products;
    }
    public static String allProductsCategory(String categorie) {
    	
    	/** for category in any generation and that have not subcategoies  check if it has products or not and return a String of its products if exist **/
    	String idProductsString="";
    	String[] filles=Categories.categoriesFilles(categorie);
    	if(filles.length==0) {
    		String[] idProducts=Categories.hasProducts(categorie);
    		if(idProducts.length==0) {
    			return "";
    		}
    		else {
        		idProductsString +=String.join(",", idProducts);
        		return ","+idProductsString ;
    		}

    		}
    	else {
    		for(String fille :filles) {
    			idProductsString+=allProductsCategory(fille);
                  }
    		return idProductsString;
      	}
  
    }
    public static String[] sortedAllProductsCategory(String categorie) {
    	String chaine=allProductsCategory(categorie);
    	if(chaine.length()==0) {
    		return new String[] {};
    	}
    	String stringProducts ="("+allProductsCategory(categorie).substring(1)+")";
    	String[] products=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            Statement stmt = connexion.createStatement ();
            ResultSet res =stmt.executeQuery("SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT\n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a\n"
            		+ "UNION ALL\n"
            		+ "SELECT b.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT\n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b");
            /* nombre de produits */
            Statement stmt2 =connexion.createStatement ();
            ResultSet reslt = stmt2.executeQuery("SELECT COUNT(IDPRODUIT) FROM (SELECT a.* FROM\n"
            		+ "(SELECT PRODUIT.IDPRODUIT, INTITULE FROM PRODUIT JOIN OFFRE on PRODUIT.IDPRODUIT = OFFRE.IDPRODUIT \n"
            		+ "WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"\n"
            		+ "GROUP BY PRODUIT.IDPRODUIT,OFFRE.IDPRODUIT, INTITULE ORDER BY  COUNT(OFFRE.IDPRODUIT)  DESC, INTITULE )  a \n"
            		+ "UNION ALL \n"
            		+ "SELECT b.* FROM \n"
            		+ "(SELECT PRODUIT.IDPRODUIT,INTITULE FROM PRODUIT  WHERE PRODUIT.IDPRODUIT IN "+ stringProducts+"  AND PRODUIT.IDPRODUIT \n"
            		+ "NOT IN (SELECT DISTINCT OFFRE.IDPRODUIT FROM OFFRE) ORDER BY INTITULE) b)");
                reslt.next();
                int nbrProducts=reslt.getInt(1);
                products=new String[nbrProducts];
                    for(int i=0;i<nbrProducts;i++){
                        res.next();
                    	products[i]=res.getString(1);
                }
            
            
            connexion.close();
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return products;
    }
    public static String[] personalRecomendedCategories(String mailConnectedUser) {
    	String[] recomendedcategories=new String[] {};
    	try {
    		
            DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());   // Enregistrement du driver Oracle
            Connection connexion = DriverManager.getConnection(CONN_URL, USER, PASSWD);  // Etablissement de la connection
            /* recuperer id client */
            PreparedStatement query1=connexion.prepareStatement("SELECT IDUTILISATEUR FROM CLIENT WHERE MAIL = ?");
            query1.setString(1, mailConnectedUser);
            ResultSet result1 =query1.executeQuery();
            result1.next();
            int ID =result1.getInt(1);
            System.out.println(ID);
            /* recuperer trending categories for this client */
            PreparedStatement query2=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom;\n"
            		+ "\n"
            		+ "\n"
            		+ "Select hierarchie.nomfille\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC;\n"
            		+ "\n"
            		+ "\n"
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query2.setInt(1, 5);
            ResultSet result2 =query2.executeQuery();
            PreparedStatement query3=connexion.prepareStatement("CREATE VIEW MostBidOn AS\n"
            		+ "Select categorie.nom\n"
            		+ "FROM (Categorie join Produit on Produit.NomCategorie = Categorie.nom) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "Where Offre.IdUtilisateur = ? and  offre.idProduit not in (Select idProduit from achat)\n"
            		+ "group by (categorie.nom)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");
            Statement smt =connexion.createStatement ();
            smt.executeQuery( "CREATE VIEW Mothers AS\n"
            		+ "Select distinct hierarchie.Nommere as nom\n"
            		+ "From MostBidOn join hierarchie on hierarchie.nomfille = MostBidOn.nom");
            Statement smt2 =connexion.createStatement ();
            smt2.executeQuery("Select  count(hierarchie.nomfille)\n"
            		+ "From ((hierarchie join mothers on mothers.nom = hierarchie.nommere) join Produit on Produit.NomCategorie = hierarchie.nomfille) join offre on offre.idProduit = Produit.idProduit\n"
            		+ "group by (hierarchie.nomfille)\n"
            		+ "Order by count(Offre.DATEHEUREDEPOTOFFRE) DESC");           		
            Statement smt3 =connexion.createStatement ();
            smt3.executeQuery("Drop View MostBidON");
            Statement smt4=connexion.createStatement ();
            smt4.executeQuery("Drop View Mothers");
            		+ "Drop View Mothers"        
      
            		+ "Drop View MostBidON;\n"
            		+ "Drop View Mothers");
            query3.setInt(1,5);
            ResultSet result3 =query3.executeQuery();
            result3.next();
            int nbrCategories=result3.getInt(1);
            System.out.println(nbrCategories);
            if(result2.next()) {
            	for(int i=0 ;i< nbrCategories;i++) {
            		recomendedcategories[i]=result2.getString(1);
            		result2.next();
            	}
            }
            connexion.close();
        
        } 
        catch (SQLException e) {
            System.err.println("failed");
            e.printStackTrace(System.err);
        }
    	return recomendedcategories;
    }
   
    public static void main(String[] args) {
//        String string=allProductsCategory("CHAUSSURES DE GOLF");
//    	System.out.println( string);
    	String[] string =personalRecomendedCategories("antoin@gmail.com");
    	System.out.println( string[1]); 
    }
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2033)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3797)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1945)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1976)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3054)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3237)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3014)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3349)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1526)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1279)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
